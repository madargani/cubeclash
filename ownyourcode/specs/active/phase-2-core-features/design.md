# Technical Design: Core Competition Features (Phase 2)

> Generated by OwnYourCode based on your stack, official docs, and production patterns.

## Overview

Phase 2 builds on the Phase 1 foundation to enable real-time speedcubing competitions. We add scramble generation (cubing.js), a cstimer-like interface, live leaderboards, and round management. The architecture leverages Socket.IO rooms for synchronized state distribution.

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Client (React)                              │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────┐  │
│  │   RoomLobby     │  │   TimerView     │  │    LeaderboardPanel     │  │
│  │  ┌───────────┐  │  │  ┌───────────┐  │  │  ┌─────────────────┐    │  │
│  │  │ Nickname  │  │  │  │ Scramble  │  │  │  │ Rank | Nick | Time│   │  │
│  │  │   Input   │  │  │  │  Display  │  │  │  │ 1    | Alice| 12.34│   │  │
│  │  └───────────┘  │  │  └───────────┘  │  │  │ 2    | Bob  | 15.21│   │  │
│  │  ┌───────────┐  │  │  ┌───────────┐  │  │  │ 3    | You  | 18.90│   │  │
│  │  │ Join/Wait │  │  │  │  Big Timer│  │  │  └─────────────────┘    │  │
│  │  │   State   │  │  │  │  00:00.00 │  │  │                         │  │
│  │  └───────────┘  │  │  └───────────┘  │  └─────────────────────────┘  │
│  └─────────────────┘  │  ┌───────────┐                                │
│                       │  │ Spacebar  │                                │
│                       │  │  Hint     │                                │
│                       │  └───────────┘                                │
│                       └─────────────────┘                              │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ Socket.IO WebSocket
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           Server (Express + Socket.IO)                   │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                        Socket.IO Handlers                         │   │
│  ├──────────────────┬──────────────────┬────────────────────────────┤   │
│  │   Room Manager   │   Race Engine    │     Leaderboard Manager    │   │
│  │  ┌────────────┐  │  ┌────────────┐  │  ┌──────────────────────┐  │   │
│  │  │rooms: Map  │  │  │generate    │  │  │results: Map          │  │   │
│  │  │users: Map  │  │  │scramble    │  │  │sortByTime()          │  │   │
│  │  │create()    │  │  │startRound()│  │  │broadcastUpdate()     │  │   │
│  │  │join()      │  │  │endRound()  │  │  │                      │  │   │
│  │  └────────────┘  │  └────────────┘  │  └──────────────────────┘  │   │
│  └──────────────────┴──────────────────┴────────────────────────────┘   │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │                     cubing.js Integration                       │     │
│  │   import { randomScrambleForEvent } from "cubing/scramble"      │     │
│  │   const scramble = await randomScrambleForEvent("333")          │     │
│  └────────────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────┘
```

## Data Flow

### Round Start Flow

1. **Host clicks "Start Round"** → Client emits `round:start`
2. **Server generates scramble** → Calls `randomScrambleForEvent("333")`
3. **Server broadcasts scramble** → Emits `scramble:new` to all in room
4. **Clients display scramble** → TimerView shows scramble + ready state
5. **Timer enabled** → Users can now start timing

```
Host Client                Server                  Other Clients
   │    round:start ───────────►│
   │                            │  generateScramble()
   │                            │  rooms[roomId].currentScramble = scramble
   │◄────── scramble:new ───────│────────── scramble:new ─────►│
   │   (display scramble)       │                        (display scramble)
   │   (enable timer)           │                        (enable timer)
```

### Solve Submission Flow

1. **User completes solve** → Hits spacebar, timer stops
2. **Client submits** → Emits `solve:submit` with time in ms
3. **Server validates** → Checks round active, time > 0
4. **Server updates leaderboard** → Adds to results Map
5. **Server broadcasts** → Emits `leaderboard:update` to room
6. **All clients update** → LeaderboardPanel re-renders with new rankings

```
User Client                Server                  All Clients
   │    solve:submit ──────────►│
   │    { time: 12345 }         │  validate()
   │                            │  leaderboard.addResult()
   │◄─── leaderboard:update ────│────── leaderboard:update ───►│
   │   (update display)         │                        (update display)
```

## Components

| Component | Purpose | New/Modified | Location |
|-----------|---------|--------------|----------|
| `NicknameInput` | Set user nickname before/during room join | New | `client/src/components/NicknameInput.tsx` |
| `TimerView` | Main timer UI with scramble display | New | `client/src/components/TimerView.tsx` |
| `ScrambleDisplay` | Show current scramble text | New | `client/src/components/ScrambleDisplay.tsx` |
| `Timer` | Stopwatch logic + spacebar handling | New | `client/src/components/Timer.tsx` |
| `InspectionCountdown` | 15-second inspection timer | New | `client/src/components/InspectionCountdown.tsx` |
| `LeaderboardPanel` | Live race results table | New | `client/src/components/LeaderboardPanel.tsx` |
| `RoundControls` | Host controls (start/end round) | New | `client/src/components/RoundControls.tsx` |
| `RoomStatus` | Current round state indicator | New | `client/src/components/RoomStatus.tsx` |
| `App.tsx` | Main app orchestration | Modified | `client/src/App.tsx` |
| `useTimer` | Timer state management hook | New | `client/src/hooks/useTimer.ts` |
| `useSocket` | Socket.IO event handlers | Modified | `client/src/hooks/useSocket.ts` |
| `rooms.ts` | Extended room state management | Modified | `server/src/rooms.ts` |
| `races.ts` | Race/round state management | New | `server/src/races.ts` |
| `leaderboard.ts` | Leaderboard logic | New | `server/src/leaderboard.ts` |
| `scramble.ts` | cubing.js integration | New | `server/src/scramble.ts` |

## State Management

### Client State (React)

| State | Type | Location | Initial Value |
|-------|------|----------|---------------|
| `nickname` | string | `App.tsx` | `""` |
| `currentScramble` | string | `App.tsx` | `null` |
| `roundState` | enum | `App.tsx` | `"waiting"` |
| `timerState` | enum | `useTimer` | `"idle"` |
| `currentTime` | number | `useTimer` | `0` |
| `inspectionTime` | number | `useTimer` | `15` |
| `leaderboard` | array | `App.tsx` | `[]` |
| `isHost` | boolean | `App.tsx` | `false` |

### Server State (Node.js)

| State | Type | Location | Description |
|-------|------|----------|-------------|
| `rooms` | Map<string, Room> | `rooms.ts` | Extended with round state |
| `races` | Map<string, Race> | `races.ts` | Active/completed races per room |
| `leaderboards` | Map<string, Result[]> | `leaderboard.ts` | Current round results |
| `userNicknames` | Map<string, string> | `rooms.ts` | socket.id → nickname mapping |

**Extended Room Interface:**
```typescript
interface Room {
  id: string;
  hostId: string;
  members: string[];
  nicknames: Map<string, string>; // socket.id → nickname
  currentRound?: string; // race ID
}
```

**Race Interface:**
```typescript
interface Race {
  id: string;
  roomId: string;
  scramble: string;
  state: "waiting" | "active" | "ended";
  startedAt: Date;
  endedAt?: Date;
  results: RaceResult[];
}
```

**RaceResult Interface:**
```typescript
interface RaceResult {
  socketId: string;
  nickname: string;
  time: number; // milliseconds
  status: "solving" | "finished" | "dnf";
  submittedAt: Date;
}
```

## Error Handling

| Error Type | User Sees | Code Does |
|------------|-----------|-----------|
| Invalid nickname | "Nickname must be 3-20 characters" | Prevent submit, focus field |
| Scramble generation fails | "Failed to generate scramble. Retrying..." | Retry with exponential backoff |
| Timer already running | Ignore second spacebar press | Debounce handling |
| Submit outside active round | "Round has ended. Wait for next round." | Reject submission |
| Negative time | "Invalid time. Please try again." | Validate time > 0 |
| User disconnected mid-solve | Marked as DNF on leaderboard | Auto-DNF on disconnect |
| Host disconnects | "Host left. New host: [nickname]" | Reassign host |

## Security Considerations

- [ ] Validate all times server-side (prevent client-side tampering)
- [ ] Rate limit submissions (prevent spam)
- [ ] Sanitize nicknames (prevent XSS)
- [ ] Verify host actions server-side (prevent non-host from starting rounds)
- [ ] No sensitive data in localStorage (nicknames are public)

## Patterns from Research

### cubing.js Integration (Official Pattern)
```typescript
import { randomScrambleForEvent } from "cubing/scramble";

// Server-side scramble generation
export async function generateScramble(event: string = "333"): Promise<string> {
  const scramble = await randomScrambleForEvent(event);
  return scramble.toString();
}
```

### Timer Implementation (cstimer-style)
```typescript
// Use performance.now() for precision
const startTime = performance.now();
// ... solving ...
const endTime = performance.now();
const duration = endTime - startTime; // milliseconds

// Spacebar hold detection
const HOLD_DURATION = 300; // ms
let holdStart: number;

const handleKeyDown = (e: KeyboardEvent) => {
  if (e.code === "Space") {
    holdStart = performance.now();
    // Show "ready" visual after HOLD_DURATION
  }
};

const handleKeyUp = (e: KeyboardEvent) => {
  if (e.code === "Space") {
    const holdDuration = performance.now() - holdStart;
    if (holdDuration >= HOLD_DURATION) {
      startTimer();
    }
  }
};
```

### Socket.IO Broadcast Pattern
```typescript
// Broadcast to all in room except sender
socket.to(roomId).emit("user:joined", nickname);

// Broadcast to ALL in room (including sender)
io.to(roomId).emit("leaderboard:update", results);
```

### Leaderboard Sorting
```typescript
// Sort: finished first (by time), then DNF, then solving
const sorted = results.sort((a, b) => {
  if (a.status === "finished" && b.status === "finished") {
    return a.time - b.time;
  }
  if (a.status === "finished") return -1;
  if (b.status === "finished") return 1;
  if (a.status === "dnf") return 1;
  if (b.status === "dnf") return -1;
  return 0;
});
```

### Handle Tab Visibility (Prevent cheating)
```typescript
document.addEventListener("visibilitychange", () => {
  if (document.hidden && timerState === "running") {
    // Option 1: Pause timer
    // Option 2: Mark as DNF
    // Option 3: Continue (trust user)
    // Phase 2: Continue with warning
  }
});
```

## File Structure

```
apps/
├── client/src/
│   ├── components/
│   │   ├── NicknameInput.tsx
│   │   ├── TimerView.tsx
│   │   ├── ScrambleDisplay.tsx
│   │   ├── Timer.tsx
│   │   ├── InspectionCountdown.tsx
│   │   ├── LeaderboardPanel.tsx
│   │   ├── RoundControls.tsx
│   │   └── RoomStatus.tsx
│   ├── hooks/
│   │   ├── useTimer.ts
│   │   └── useSocket.ts (modified)
│   ├── types/
│   │   └── index.ts
│   └── App.tsx (modified)
└── server/src/
    ├── rooms.ts (modified)
    ├── races.ts (new)
    ├── leaderboard.ts (new)
    ├── scramble.ts (new)
    ├── types.ts (modified)
    └── index.ts (modified)
```

## Dependencies

### New Dependencies (Server)
```bash
cd apps/server
npm install cubing
```

### No New Dependencies (Client)
All client functionality uses existing React + Socket.IO stack.

## Environment Variables

| Variable | Default | Purpose |
|----------|---------|---------|
| `PORT` | 3000 | Server port |
| `CLIENT_URL` | http://localhost:5173 | CORS origin |

---

> **Junior:** Review this design. Check if the data flows make sense for your implementation. Modify component locations or state management if your project structure differs.
